/**********************************************************************************************************************
Author: 			Andrea ENRICI
Description: 	Parser for the communication Patterns
***********************************************************************************************************************/

options {
	/* These are all the options offered by Javacc set with their default values */
//  LOOKAHEAD = 2;
//  CHOICE_AMBIGUITY_CHECK = 2;
//  OTHER_AMBIGUITY_CHECK = 1;
//  STATIC = true;
//  DEBUG_PARSER = false;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  ERROR_REPORTING = true;
//  JAVA_UNICODE_ESCAPE = false;
//  UNICODE_INPUT = false;
//  IGNORE_CASE = false;
//  USER_TOKEN_MANAGER = false;
//  USER_CHAR_STREAM = false;
//  BUILD_PARSER = true;
//  BUILD_TOKEN_MANAGER = true;
//  SANITY_CHECK = true;
	/*When LOOKAHEAD is more than 1, lookahead adequacy checking is not performed. Option FORCE_LA_CHECK must be set to true to
	 * force checking */
//  FORCE_LA_CHECK = true;
	MULTI=true;	/* Generate a multimode parse tree */
	KEEP_LINE_COLUMN = false; 
//	NODE_PREFIX="AST";
}

PARSER_BEGIN(CPparser) /* The parser class */

//package tmlCPparser;
import tmltranslator.*;//tmlcp.*;
//import tmltranslator.TMLCP;
import java.util.*;
import myutil.*;

public class CPparser {

	public static int test;
	public static tmltranslator.TMLCP topCP = new tmltranslator.TMLCP( "noName", new Object() );

  /* Main entry point. */
  public static void main(String args[]) /*throws ParseException*/ {
		
    CPparser parser = new CPparser(System.in);
		try	{
    ASTStartSymbol n = parser.StartSymbol();
		n.dump("");
		System.out.println("Thank you.");
		}
		catch (Exception e)	{
		System.out.println("Ooops");
		System.out.println(e.getMessage());
		e.printStackTrace();
		}
  }
}

PARSER_END(CPparser)

SKIP:
{
	" "
| "\t"
| "\n"
| "\r"
| < "#" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >	/* Definition of comments */
}

/* The order in which TOKENs are declared matters! Moving the token declaration for the reserved keywords after the one for the
 * identifiers makes parsing to go bananas as any reserved keyword is instead matched as an identifier! */
/* Reserved keywords */
TOKEN:
{
	< BOOLTYPE: "BOOL" >
|	< INTTYPE: "INT" >
| < START_KW: "START" >
|	< ENDBLOCK: "END" >
|	< MAINBLOCK: "MAIN" >
|	< CP: "COMMUNICATION_PATTERN" >
| < ACTIVITY_KW: "ACTIVITY" >
| < SCENARIO_KW: "SCENARIO" >
| < INCLUDE: "INCLUDE" >
| < TRUECONST: "TRUE" >
| < FALSECONST: "FALSE" >
| < STORAGE_KW: "STORAGE" >
| < CONTROLLER_KW: "CONTROLLER" >
| < TRANSFER_KW: "TRANSFER" >
| < ACTION_KW: <TRANSFER_ACT> | <TRANSFER_REQ> | <TRANSFER_DONE> | <READ_ACT> | <WRITE_ACT> >
| < #TRANSFER_ACT: "Transfer" >
| < #TRANSFER_REQ: "TransferRequest" >
| < #TRANSFER_DONE: "TransferDone" >
| < #READ_ACT: "Read" >
| < #WRITE_ACT: "Write" >
| < EXTENSION: <CP_LIB> >
| < #CP_LIB: ".cplib" >
}

/* Operators */
TOKEN:
{
	< BLOCKSTART: "{" >
|	< BLOCKEND: "}" >
|	< JOINSTART: "<" >
|	< JOINEND: ">" >
|	< SEQUENCING: ";" >
|	< PARALLELISM: "*" >
|	< SELECTION: "+" >
|	< GUARDSTART: "[" >
|	< GUARDEND: "]" >
|	< ITERATIONSTART: "(" >
|	< ITERATIONEND: ")" >
|	< SEPARATOR: "," >
| < ASSIGNMENT: "=" >
| < EQUALITY: "==" >
| < BITWISEOR: "|" >
| < LOGICALOR: "||" >
| < BITWISEAND: "&" >
| < LOGICALAND: "&&" >
| < BITWISEEXOR: "^" >
| < INCREMENT: "++" >
| < DECREMENT: "--" >
| < STARTAD: "<>;" >
| < ORDEROPERATOR: <SEQUENCING> | <PARALLELISM> >
//| < EOL: ["\n" | "\r" | "\r\n" >
| < PATH_SEPARATOR: "/" >
| < QUOTATION_MARK: "\"" >
| < FULL_STOP: "." >
}

/* Identifiers */
TOKEN:
{
	< IDENTIFIER: <LETTER> (<UNDERSCORE> | <LETTER> | <DIGIT>)* (<LETTER> | <DIGIT>) >
| < #LETTER: ["a"-"z","A"-"Z"] >
|	< #DIGIT: ["0"-"9"] >
|	< UNDERSCORE: "_" >
//| < INCLUDE_SYMBOL: "$" >
}

/* Literals */
TOKEN:
{
	< INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? >
| < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
}


/* List of productions defining the non-terminals. They are implemented as methods of the above parser class*/
/* Root production. */
ASTStartSymbol StartSymbol():	/* The left hand side of this production is called Input and must be followed by colon */
{
	tmltranslator.tmlcp.TMLCPSection CPprova = new tmltranslator.tmlcp.TMLCPSection( "NoName", new Object() );
}
{
	( IncludeFiles() )*
	( MappingList() )*
	CommunicationPattern( CPprova )

	ActivityDiagram()

	/* Size retains its value from its declaration on, in successive semantic actions within the same production rule */
	{ int size = topCP.getSections(); System.out.println( "The data structure contains " + size + " CP sections\n" );}

	( SequenceDiagram() )+
	<EOF>		/* Force the parser to reach EOF */
	{ return jjtThis; }
}

/********************************************************************************************************************************
Include Files Section: the grammar for parsing the inclusion of library files
********************************************************************************************************************************/
void IncludeFiles():
{}
{
	<INCLUDE> <QUOTATION_MARK> (<FULL_STOP>)? (<PATH_SEPARATOR>)? ID() (<PATH_SEPARATOR> ID() )* <EXTENSION> <QUOTATION_MARK>
}

/* Scenario with mapping parameters within parentheses (the CP is mapped onto a list of architecture units) */
void MappingList():
{}
{
	ID() <ITERATIONSTART> ID() ( <SEPARATOR> ID() )+ <ITERATIONEND>
}
/********************************************************************************************************************************
Activity Diagram Section
********************************************************************************************************************************/
void CommunicationPattern( tmltranslator.tmlcp.TMLCPSection CPprova ) :
{
	Object fake = new Object();	
	String name = "noName";
	tmltranslator.tmlcp.TMLCPSection mainCP = new tmltranslator.tmlcp.TMLCPSection( name, fake );
	tmltranslator.tmlcp.TMLCPStart CPStart = new tmltranslator.tmlcp.TMLCPStart( name, fake );
}
{
	//Add to the data structure the start of the main Communication Pattern
	<CP> name = ID()
	{ topCP.setName( name );
		CPStart.setName( name );
		mainCP.setStartElement( CPStart );
		mainCP.addTMLCPElement( CPStart ); }
	//<EOL>

	mainCP = AD_CP_Body() { topCP.setMainCP( mainCP ); }
	
	<ENDBLOCK>
	
}

//For Activity Diagrams that are not the main Communication Pattern
void ActivityDiagram():
{}
{
	<START_KW> <ACTIVITY_KW>  ID()

	AD_CP_Body()

	<ENDBLOCK>
	
}

//The body of an Activity Diagram, regardless if it is the AD for the mainCP or for nested CPs
//This production rules fills all attributes of a TMLCPSection object but the start.
// The latter is added separately either in ActivityDiagram() for nested AD or in CommunicationPattern() for the mainCP. This
// choice is due to the original construction of the grammar.
//ActivityDiagram() and CommunicationPattern() then fill the topCP

tmltranslator.tmlcp.TMLCPSection AD_CP_Body():
{
	tmltranslator.TMLAttribute variable = new tmltranslator.TMLAttribute();
	tmltranslator.tmlcp.TMLCPSection AD = new tmltranslator.tmlcp.TMLCPSection( "noName", new Object() );
}
{
	//An Activity Diagram is either composed of only ADs or only SDs. In either case, at least one AD or one SD must be declared
	( ActivityDeclaration() ( ActivityDeclaration()	)* )
	|
	( ScenarioDeclaration() ( ScenarioDeclaration() )* )

	(
	variable = VariableDeclaration()
	{ AD.addVariable( variable ); /*System.out.println( "Found attribute " + attribute.getName() + "\n" );*/ }
	)+

	//VariableInitialization()	no more existing to fill the data structure in a simple way

	MainModule()

	//Return the CPSection filled with the parameters
	{ return AD; }
}

//Fill an ADelement from the declaration of these elements, it will be added to the data structure in production rule AD_CP_Body
void ActivityDeclaration():
{}
{
	<ACTIVITY_KW> ID()
	//( <SEPARATOR> ID() )*

}

/* Scenario declarations matching production. */
void ScenarioDeclaration():
{}
{
  <SCENARIO_KW> ID() (<SEPARATOR> ID())*
}

/* 	Due to the need to construct a data structure for parsing the language I am modifying the grammar:
		in this case each variable must be declared with its initial value (keep it simple). No declaration list */
/* Variable declarations matching production. */
//tmltranslator.tmlcp.TMLAttribute VariableDeclaration():
tmltranslator.TMLAttribute VariableDeclaration():
{
	Token t;
	tmltranslator.TMLAttribute attribute = new tmltranslator.TMLAttribute();
	tmltranslator.TMLType myType = new tmltranslator.TMLType( 0 );
}
{
  ( t = <BOOLTYPE> /*{ attribute.type = t.image }*/ | t = <INTTYPE> /*{ attribute.type = t.image }*/ )
	{
	/* Convoluted, but did not want to modify TMLType */
	myType.setType( myType.getType( t.image ) ); 
	attribute.type = myType;
	}

	attribute.name = ID() <ASSIGNMENT>
	( t = <TRUECONST> | t = <FALSECONST> | t= <INTEGER_LITERAL> ) { attribute.initialValue = t.image; }

	{ return attribute; }
}

/* Variable initialization matching production. */
/*void VariableInitialization():
{}
{
  //BooleanInitialization() | IntegerInitialization()
	(ID() <ASSIGNMENT> (<TRUECONST> | <FALSECONST> | <INTEGER_LITERAL>) )+
}*/

/* Start of Module matching production. */
void MainModule():
{}
{
  <MAINBLOCK>
	<STARTAD> TOExpression() (JoinList())*
	<ENDBLOCK>
}

void JoinList():
{}
{
	<JOINSTART> ID() (<SEPARATOR> ID())+ <JOINEND> <SEQUENCING>
	TOExpression()
}
/* Make it work only for joining one scenario: there is only one join scenario after the join. */
/* Right-recursive grammar for Total Order (TO) expressions. Parses also {scX} and unbalanced curly parentheses. Priority is
 * encoded in the grammar to the parallelism * operator. */
void TOExpression():
{}
{
	TOTerm() TOExpressionPrime() 
}

void TOExpressionPrime():
{}
{
	<SEQUENCING> TOTerm() TOExpressionPrime()
| {}
}

void TOTerm():
{}
{
	TOFactor() TOTermPrime()
}

void TOTermPrime():
{}
{
	<PARALLELISM> TOFactor() TOTermPrime()
| {}
}

void TOFactor():
{}
{
	<BLOCKSTART> TOExpression() <BLOCKEND> (GExpression())*
| ID() (GExpression())*
}

/* Right-recursive grammar for parsing the guard expressions. Same as the above grammar for parsing TO expressions. No priority is
 * given to operators */
void GExpression():
{}
{
	GTerm() GExpressionPrime()
}

void GExpressionPrime():
{}
{
	<LOGICALOR> GTerm() GExpressionPrime()
| <LOGICALAND> GTerm() GExpressionPrime()
| {}
}

void GTerm():
{}
{
	GFactor() GTermPrime()
}

void GTermPrime():
{}
{
	GFactor() GTermPrime()
| {}
}

void GFactor():
{}
{
	<GUARDSTART> GExpression() <GUARDEND>
| ID()
}

/********************************************************************************************************************************
Sequence Diagram Section
********************************************************************************************************************************/

void SequenceDiagram():
{}
{
	<SCENARIO_KW> ID()
	ArchitectureNodes()
	(IntegerInitialization())*
	(IntegerDeclaration())*
	<MAINBLOCK> (Action())+
	<ENDBLOCK>
	<ENDBLOCK>
}

void ArchitectureNodes():
{}
{
	<STORAGE_KW> ID() <SEPARATOR> ID()
	<CONTROLLER_KW> ID()
	<TRANSFER_KW> ID() (<SEPARATOR> ID())*

}

void IntegerInitialization():
{}
{
	<INTTYPE> ID() ( <SEPARATOR> ID())*
}

void IntegerDeclaration():
{}
{
	ID() <ASSIGNMENT> <INTEGER_LITERAL>
}


void Action():
{}
{
	<ACTION_KW> <ITERATIONSTART> ID() (<SEPARATOR> ID())* <ITERATIONEND> <SEQUENCING>
}

String ID():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ jjtThis.setName(t.image); return t.image; }
}
