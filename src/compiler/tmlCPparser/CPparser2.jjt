/**********************************************************************************************************************
Author: 			Andrea ENRICI
Description: 	Parser for the communication Patterns
***********************************************************************************************************************/

options {
	/* These are all the options offered by Javacc set with their default values */
//  LOOKAHEAD = 2;
//  CHOICE_AMBIGUITY_CHECK = 2;
//  OTHER_AMBIGUITY_CHECK = 1;
//  STATIC = true;
//  DEBUG_PARSER = false;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  ERROR_REPORTING = true;
//  JAVA_UNICODE_ESCAPE = false;
//  UNICODE_INPUT = false;
//  IGNORE_CASE = false;
//  USER_TOKEN_MANAGER = false;
//  USER_CHAR_STREAM = false;
//  BUILD_PARSER = true;
//  BUILD_TOKEN_MANAGER = true;
//  SANITY_CHECK = true;
	/*When LOOKAHEAD is more than 1, lookahead adequacy checking is not performed. Option FORCE_LA_CHECK must be set to true to
	 * force checking */
//  FORCE_LA_CHECK = true;
	MULTI=true;	/* Generate a multimode parse tree */
	KEEP_LINE_COLUMN = false; 
//	NODE_PREFIX="AST";
}

PARSER_BEGIN(CPparser) /* The parser class */

//package tmlCPparser;
import tmltranslator.*;//tmlcp.*;
//import tmltranslator.TMLCP;
import java.util.*;
import myutil.*;

public class CPparser {

	public static tmltranslator.TMLCP topCP = new tmltranslator.TMLCP( "noName", new Object() );

  /* Main entry point. */
  public static void main(String args[]) /*throws ParseException*/ {
    CPparser parser = new CPparser(System.in);
		try	{
    ASTStartSymbol n = parser.StartSymbol();
		n.dump("");
		System.out.println("Thank you.");
		}
		catch (Exception e)	{
		System.out.println("Ooops");
		System.out.println(e.getMessage());
		e.printStackTrace();
		}
  }
}

PARSER_END(CPparser)

SKIP:
{
	" "
| "\t"
| "\n"
| "\r"
| < "#" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >	/* Definition of comments */
}

/* The order in which TOKENs are declared matters! Moving the token declaration for the reserved keywords after the one for the
 * identifiers makes parsing to go bananas as any reserved keyword is instead matched as an identifier! */
/* Reserved keywords */
TOKEN:
{
	< BOOLTYPE: "BOOL" >
|	< INTTYPE: "INT" >
| < START_KW: "START" >
|	< ENDBLOCK: "END" >
|	< MAINBLOCK: "MAIN" >
|	< CP: "COMMUNICATION_PATTERN" >
| < ACTIVITY_KW: "ACTIVITY" >
| < SCENARIO_KW: "SCENARIO" >
| < INCLUDE: "INCLUDE" >
| < TRUECONST: "TRUE" >
| < FALSECONST: "FALSE" >
| < STORAGE_KW: "STORAGE" >
| < CONTROLLER_KW: "CONTROLLER" >
| < TRANSFER_KW: "TRANSFER" >
| < ACTION_KW: <TRANSFER_ACT> | <TRANSFER_REQ> | <TRANSFER_DONE> | <READ_ACT> | <WRITE_ACT> >
| < #TRANSFER_ACT: "Transfer" >
| < #TRANSFER_REQ: "TransferRequest" >
| < #TRANSFER_DONE: "TransferDone" >
| < #READ_ACT: "Read" >
| < #WRITE_ACT: "Write" >
| < EXTENSION: <CP_LIB> >
| < #CP_LIB: ".cplib" >
}

/* Operators */
TOKEN:
{
	< BLOCKSTART: "{" >
|	< BLOCKEND: "}" >
|	< JOINSTART: "<" >
|	< JOINEND: ">" >
|	< SEQUENCING: ";" >
|	< PARALLELISM: "*" >
|	< SELECTION: "+" >
|	< GUARDSTART: "[" >
|	< GUARDEND: "]" >
|	< ITERATIONSTART: "(" >
|	< ITERATIONEND: ")" >
|	< SEPARATOR: "," >
| < ASSIGNMENT: "=" >
| < EQUALITY: "==" >
| < BITWISEOR: "|" >
| < LOGICALOR: "||" >
| < BITWISEAND: "&" >
| < LOGICALAND: "&&" >
| < BITWISEEXOR: "^" >
| < INCREMENT: "++" >
| < DECREMENT: "--" >
| < STARTAD: "<>;" >
| < ORDEROPERATOR: <SEQUENCING> | <PARALLELISM> >
//| < EOL: ["\n" | "\r" | "\r\n" >
| < PATH_SEPARATOR: "/" >
| < QUOTATION_MARK: "\"" >
| < FULL_STOP: "." >
}

/* Identifiers */
TOKEN:
{
	< IDENTIFIER: <LETTER> (<UNDERSCORE> | <LETTER> | <DIGIT>)* (<LETTER> | <DIGIT>) >
| < #LETTER: ["a"-"z","A"-"Z"] >
|	< #DIGIT: ["0"-"9"] >
|	< UNDERSCORE: "_" >
//| < INCLUDE_SYMBOL: "$" >
}

/* Literals */
TOKEN:
{
	< INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? >
| < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
}


/* List of productions defining the non-terminals. They are implemented as methods of the above parser class*/
/* Root production. */
ASTStartSymbol StartSymbol():	/* The left hand side of this production is called Input and must be followed by colon */
{}
{
	( IncludeFiles() )*
	( MappingList() )*
	CommunicationPattern()
	( ActivityDiagram() )*
	( SequenceDiagram() )+
	<EOF>		/* Force the parser to reach EOF */
	{ return jjtThis; }
}

/********************************************************************************************************************************
Include Files Section: the grammar for parsing the inclusion of library files
********************************************************************************************************************************/
void IncludeFiles():
{}
{
	<INCLUDE> <QUOTATION_MARK> (<FULL_STOP>)? (<PATH_SEPARATOR>)? ID() (<PATH_SEPARATOR> ID() )* <EXTENSION> <QUOTATION_MARK>
}

/* Scenario with mapping parameters within parentheses (the CP is mapped onto a list of architecture units) */
void MappingList():
{}
{
	ID() <ITERATIONSTART> ID() ( <SEPARATOR> ID() )+ <ITERATIONEND>
}
/********************************************************************************************************************************
Activity Diagram Section
********************************************************************************************************************************/
void CommunicationPattern():
{
	String name;
}
{
	<CP> name = ID() { topCP.setName( name ); }
	AD_CP_Body()
	<ENDBLOCK>
}

void ActivityDiagram():
{}
{
	<START_KW> <ACTIVITY_KW> ID()
	AD_CP_Body()
	<ENDBLOCK>
}

void AD_CP_Body():
{}
{
	( ActivityDeclaration() )*
	ScenarioDeclaration()
	VariableDeclaration()
	VariableInitialization()
	MainModule()
}

void ActivityDeclaration():
{}
{
	<ACTIVITY_KW> ID() ( <SEPARATOR> ID() )*
}

/* Scenario declarations matching production. */
void ScenarioDeclaration():
{}
{
  <SCENARIO_KW> ID() (<SEPARATOR> ID())*
}

/* Variable declarations matching production. */
void VariableDeclaration():
{}
{
  ( (<BOOLTYPE> | <INTTYPE>) ID() (<SEPARATOR> ID())* )+
}

/* Variable declarations matching production. */
void VariableInitialization():
{}
{
  //BooleanInitialization() | IntegerInitialization()
	(ID() <ASSIGNMENT> (<TRUECONST> | <FALSECONST> | <INTEGER_LITERAL>) )+
}

/* Initialization of a boolean variable */
//*void BooleanInitialization(): 
//*{}
//*{
//*	//<BOOLTYPE> <IDENTIFIER> <ASSIGNMENT> (<TRUECONST> | <FALSECONST>)
//*	<IDENTIFIER> <ASSIGNMENT> (<TRUECONST> | <FALSECONST>)
//*}
//*
//*/* Initialization of an integer variable */
//*void IntegerInitialization():
//*{}
//*{
//*	//<INTTYPE> <IDENTIFIER> <ASSIGNMENT> <INTEGER_LITERAL>
//*	<IDENTIFIER> <ASSIGNMENT> <INTEGER_LITERAL>
//*}
	
/* Start of Module matching production. */
void MainModule():
{}
{
  <MAINBLOCK>
	<STARTAD> TOExpression() (JoinList())*
	<ENDBLOCK>
}

void JoinList():
{}
{
	<JOINSTART> ID() (<SEPARATOR> ID())+ <JOINEND> <SEQUENCING>
	TOExpression()
}
/* Make it work only for joining one scenario: there is only one join scenario after the join. */
/* Right-recursive grammar for Total Order (TO) expressions. Parses also {scX} and unbalanced curly parentheses. Priority is
 * encoded in the grammar to the parallelism * operator. */
void TOExpression():
{}
{
	TOTerm() TOExpressionPrime() 
}

void TOExpressionPrime():
{}
{
	<SEQUENCING> TOTerm() TOExpressionPrime()
| {}
}

void TOTerm():
{}
{
	TOFactor() TOTermPrime()
}

void TOTermPrime():
{}
{
	<PARALLELISM> TOFactor() TOTermPrime()
| {}
}

void TOFactor():
{}
{
	<BLOCKSTART> TOExpression() <BLOCKEND> (GExpression())*
| ID() (GExpression())*
}

/* Right-recursive grammar for parsing the guard expressions. Same as the above grammar for parsing TO expressions. No priority is
 * given to operators */
void GExpression():
{}
{
	GTerm() GExpressionPrime()
}

void GExpressionPrime():
{}
{
	<LOGICALOR> GTerm() GExpressionPrime()
| <LOGICALAND> GTerm() GExpressionPrime()
| {}
}

void GTerm():
{}
{
	GFactor() GTermPrime()
}

void GTermPrime():
{}
{
	GFactor() GTermPrime()
| {}
}

void GFactor():
{}
{
	<GUARDSTART> GExpression() <GUARDEND>
| ID()
}

/********************************************************************************************************************************
Sequence Diagram Section
********************************************************************************************************************************/

void SequenceDiagram():
{}
{
	<SCENARIO_KW> ID()
	ArchitectureNodes()
	(IntegerInitialization())*
	(IntegerDeclaration())*
	<MAINBLOCK> (Action())+
	<ENDBLOCK>
	<ENDBLOCK>
}

void ArchitectureNodes():
{}
{
	<STORAGE_KW> ID() <SEPARATOR> ID()
	<CONTROLLER_KW> ID()
	<TRANSFER_KW> ID() (<SEPARATOR> ID())*

}

void IntegerInitialization():
{}
{
	<INTTYPE> ID() ( <SEPARATOR> ID())*
}

void IntegerDeclaration():
{}
{
	ID() <ASSIGNMENT> <INTEGER_LITERAL>
}


void Action():
{}
{
	<ACTION_KW> <ITERATIONSTART> ID() (<SEPARATOR> ID())* <ITERATIONEND> <SEQUENCING>
}

String ID():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ jjtThis.setName(t.image); return t.image; }
}
