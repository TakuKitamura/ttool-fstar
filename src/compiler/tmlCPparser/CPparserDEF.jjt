/**********************************************************************************************************************
Author: 			Andrea ENRICI
Description: 	Parser for the communication Patterns
***********************************************************************************************************************/

options {
	/* These are all the options offered by Javacc set with their default values */
//  LOOKAHEAD = 2;
//  CHOICE_AMBIGUITY_CHECK = 2;
//  OTHER_AMBIGUITY_CHECK = 1;
//  STATIC = true;
//  DEBUG_PARSER = false;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  ERROR_REPORTING = true;
//  JAVA_UNICODE_ESCAPE = false;
//  UNICODE_INPUT = false;
//  IGNORE_CASE = false;
//  USER_TOKEN_MANAGER = false;
//  USER_CHAR_STREAM = false;
//  BUILD_PARSER = true;
//  BUILD_TOKEN_MANAGER = true;
//  SANITY_CHECK = true;
	/*When LOOKAHEAD is more than 1, lookahead adequacy checking is not performed. Option FORCE_LA_CHECK must be set to true to
	 * force checking */
//  FORCE_LA_CHECK = true;
//	TRACK_TOKENS = true;
//	TOKEN_EXTENDS ="BaseToken";
	MULTI=true;	/* Generate a multimode parse tree */
	KEEP_LINE_COLUMN = false; 
//	NODE_PREFIX="AST";
}

PARSER_BEGIN(CPparserDEF) /* The parser class */

//package compiler.tmlCPparserDEF;
import tmltranslator.*;
import tmltranslator.tmlcp.*;
import java.util.*;
import myutil.*;
import java.util.ArrayList;

public class CPparserDEF {

	public static TMLCP topCP = new TMLCP( "noName", new Object() );
	public static TMLCPFork fork1;
	public static TMLCPJoin join1;
	public static int counter = 0;

  /* Main entry point. */
  public static void main(String args[]) throws ParseException	{
    CPparserDEF parser = new CPparserDEF(System.in);
		try	{
    	ASTStartSymbol n = parser.StartSymbol();
			//print AST
			//n.dump("");
			//System.out.println("Thank you.");
			topCP.printDataStructure();
		}
		catch ( Exception e )	{
//			System.out.println("Ooops");
			System.out.println(e.getMessage());
//			e.printStackTrace();
		}
  }
}

PARSER_END(CPparserDEF)

SKIP:
{
	" "
| "\t"
| "\n"
| "\r"
| < "#" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >	/* One-line comment */
| < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >	/* One-line comment */
}

/* The order in which TOKENs are declared matters! Moving the token declaration for the reserved keywords after the one for the
 * identifiers makes parsing to go bananas as any reserved keyword is instead matched as an identifier! */
/* Reserved keywords */
TOKEN:
{
	< BOOL_TYPE: "bool" >
|	< INT_TYPE: "int" >
| < START_KW: "START" >
|	< ENDBLOCK: "END" >
|	< MAINBLOCK: "MAIN" >
|	< CP: "COMMUNICATION_PATTERN" >
| < ACTIVITY_DIAGRAM: "ACTIVITY" >
| < SEQUENCE_DIAGRAM: "SEQUENCE" >
| < INCLUDE: "INCLUDE" >
| < TRUECONST: "TRUE" | "true" >
| < FALSECONST: "FALSE" | "false" >
| < STORAGE_KW: "STORAGE" >
| < CONTROLLER_KW: "CONTROLLER" >
| < TRANSFER_KW: "TRANSFER" >
| < ACTION_KW: "ACT:" >
| < RCV_MSG_KW: "RCV:" >
| < SND_MSG_KW: "SND:" >
| < #TRANSFER_ACT: "Transfer" >
| < #TRANSFER_REQ: "TransferRequest" >
| < #TRANSFER_DONE: "TransferDone" >
| < #READ_ACT: "Read" >
| < #WRITE_ACT: "Write" >
| < EXTENSION: <CP_LIB> >
| < #CP_LIB: ".cplib" >
}

/* Operators */
TOKEN:
{
	< BLOCKSTART: "{" >
|	< BLOCKEND: "}" >
|	< JOINSTART: "<" >
|	< JOINEND: ">" >
|	< SEQUENCING_OP: ";" >
|	< STAR_OP: "*" >
|	< MATH_PLUS: "+" >
|	< MATH_MINUS: "-" >
|	< DOT: "." >
|	< GUARDSTART: "[" >
|	< GUARDEND: "]" >
|	< LEFT_PARENTHESIS: "(" >
|	< RIGHT_PARENTHESIS: ")" >
|	< SEPARATOR: "," >
| < ASSIGNMENT: "=" >
| < EQUALITY: "==" >
| < BITWISEOR: "|" >
| < LOGICALOR: "||" >
| < BITWISEAND: "&" >
| < LOGICALAND: "&&" >
| < BITWISEEXOR: "^" >
| < INCREMENT: "++" >
| < DECREMENT: "--" >
| < START_AD: "<>;" >
| < END_AD: "><" >
//| < ORDEROPERATOR: <SEQUENCING_OP> | <PARALLELISM_OP> >
| < EOL: ("\n" | "\r" | "\r\n") >
| < RIGHT_SLASH: "/" >
| < QUOTATION_MARK: "\"" >
}

/* Identifiers */
TOKEN:
{
	< IDENTIFIER: <LETTER> (<UNDERSCORE> | <LETTER> | <DIGIT>)* (<LETTER> | <DIGIT>) >
| < #LETTER: ["a"-"z","A"-"Z"] >
|	< #DIGIT: ["0"-"9"] >
|	< UNDERSCORE: "_" >
//| < INCLUDE_SYMBOL: "$" >
}

/* Literals */
TOKEN:
{
	< INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? >
| < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
}


/* List of productions defining the non-terminals. They are implemented as methods of the above parser class*/
/* Root production. */
ASTStartSymbol StartSymbol():	/* The left hand side of this production is called Input and must be followed by colon */
{
	int i;
	String space = " ";
	String undefinedDiagStringList = "";
	TMLCP mainCP = new TMLCP();
	TMLCPSequenceDiagram seqDiag;
	TMLCPActivityDiagram actDiag;
	ArrayList<TMLAttribute> attributeList;
}
{
	attributeList = SequenceDiagramAttributesDeclaration()	

	{	TraceManager.addDev( "#################" );
		for( TMLAttribute attr: attributeList )	{
			TraceManager.addDev( attr.toString() );
			TraceManager.addDev( "#################" );
		}
	}

	( seqDiag = SequenceDiagram( attributeList ) { mainCP.addCPSequenceDiagram( seqDiag ); } )+

	( actDiag = ActivityDiagram( mainCP ) { mainCP.addCPActivityDiagram( actDiag ); } )*

	<EOF>		/* Force the parser to reach EOF */

	{
		//Must fill the Elements of each TMLCPActivityDiagram with the correct references to CPs and SDs that could not be done before
		//encapsulate everything in one method as I do not know the type of the diagrams whose references where missing
		//topCP.correctReferences();
		ArrayList<TMLCPSequenceDiagram> sdList = mainCP.getCPSequenceDiagrams();
		ArrayList<TMLCPActivityDiagram> adList = mainCP.getCPActivityDiagrams();
		TraceManager.addDev( "***************" );
		for( TMLCPSequenceDiagram diag: sdList )	{
			TraceManager.addDev( diag.toString() );
			TraceManager.addDev( "***************" );
		}

		TraceManager.addDev( "++++++++++++++++" );
		for( TMLCPActivityDiagram diag: adList )	{
			TraceManager.addDev( diag.toString() );
			TraceManager.addDev( "++++++++++++++" );
		}
		TraceManager.addDev( "################" );
		TMLCPTextSpecification pippo = new TMLCPTextSpecification( "EMPTY" );
		TraceManager.addDev( "Printing from the parsed DS:\n" + pippo.toTextFormat( mainCP ) );
		return jjtThis;
	}
}

/********************************************************************************************************************************
Include Files Section: the grammar for parsing the inclusion of library files
********************************************************************************************************************************/
/*void IncludeFiles():
{}
{
	<INCLUDE> <QUOTATION_MARK> (<DOT>)? (<PATH_SEPARATOR>)? ID() (<PATH_SEPARATOR> ID() )* <EXTENSION> <QUOTATION_MARK>
}

void MappingList():
{}
{
	ID() <ITERATIONSTART> ID() ( <SEPARATOR> ID() )+ <ITERATIONEND>
}*/

/********************************************************************************************************************************
Sequence Diagram Section
********************************************************************************************************************************/

ArrayList<TMLAttribute> SequenceDiagramAttributesDeclaration():
{
	String instanceName, attributeName, attributeType;
	Token t, t1;
	ArrayList<TMLAttribute> attributeList = new ArrayList<TMLAttribute>();
}
{
	( instanceName = ID() "." attributeName = ID() ":" ( t = <BOOL_TYPE> | t = <INT_TYPE> )
		<ASSIGNMENT> ( t1 = <IDENTIFIER> | t1 = <INTEGER_LITERAL> | t1 = <FALSECONST> | t1 = <TRUECONST> )
	{
		if( t.image.equals("int") )	{
			attributeList.add( new TMLAttribute( attributeName, instanceName, new TMLType ( TMLType.NATURAL ), t1.image ) );
		}
		else if( t.image.equals("bool") )	{
			attributeList.add ( new TMLAttribute( attributeName, instanceName, new TMLType( TMLType.BOOLEAN ), t1.image ) );
		}
	}
	)*
	{ return attributeList; }
}

// A SD is a list of instances. Each Instance is composed of messages or actions.
TMLCPSequenceDiagram SequenceDiagram( ArrayList<TMLAttribute> attributeList ):
{
	String diagramName;
	TMLSDInstance instance;
}
{
	<SEQUENCE_DIAGRAM> diagramName = ID()
	{
		TMLCPSequenceDiagram seqDiag = new TMLCPSequenceDiagram( diagramName );
	}
	(
		instance = SequenceDiagramInstance( attributeList )
		{ seqDiag.addInstance( instance ); }
	)+
	<ENDBLOCK>

	{ return seqDiag; }
}

TMLSDInstance SequenceDiagramInstance( ArrayList<TMLAttribute> attributeList ):
{
	String instanceName, type, senderName, receiverName, messageName;
	Token t;
	TMLSDAction action;
	TMLSDMessage message;
	ArrayList<String> params = new ArrayList<String>();
}
{
	( t = <TRANSFER_KW> | t = <STORAGE_KW> | t = <CONTROLLER_KW> ) instanceName = ID()
	{ 
		TMLSDInstance instance = new TMLSDInstance( instanceName, t.image );
		for( TMLAttribute attr: attributeList )	{
			if( instanceName.equals( attr.getInstanceName() ) )	{
				//TraceManager.addDev( "Adding attribute " attr.toString() + " to instance " + instanceName );
				instance.addAttribute( attr );
			}
		}
	}

	(	<RCV_MSG_KW> senderName = ID() ":" messageName = ID() params =  MessageParameters() 
		{ message = new TMLSDMessage( messageName, senderName, instanceName, params );
			instance.addMessageFromParser( message, TMLSDEvent.RECEIVE_MESSAGE_EVENT ); }
	|
		<SND_MSG_KW> receiverName = ID() ":" messageName = ID() params = MessageParameters()
		{ message = new TMLSDMessage( messageName, instanceName, receiverName, params );
			instance.addMessageFromParser( message, TMLSDEvent.SEND_MESSAGE_EVENT ); }
	|
		action = Action( instanceName )
		{ instance.addActionFromParser( action ); }
	)+

	{ return instance; }
}

ArrayList<String> MessageParameters():
{
	String /*messageName, receiverName, senderName,*/ s;
	ArrayList<String> params = new ArrayList<String>();
}
{
	( "()" | "(" s = ID() { params.add(s); } ( "," s = ID() { params.add(s); } )* ")" )
	{
		//TMLSDMessage message = new TMLSDMessage( messageName, "", instanceName, params );
		return params;
	}
	/*|
	<SND_MSG_KW> messageName = ID() "(" ( s = ID() { params.add(s); } )* ")"
	{
		TMLSDMessage message = new TMLSDMessage( messageName, instanceName, "", params );
		return message;
	}*/
}

TMLSDAction Action( String instanceName ):
{
	String s, s1 = "";
	Token t;
}
{
	<ACTION_KW> s = ID() <ASSIGNMENT> ( s1 = BAExpression() | s1 = MAExpression() ) //( t = <INTEGER_LITERAL> | t = <FALSECONST> | t = <TRUECONST> )
	{
		TraceManager.addDev( "***** " + s1 + " *****" );
		TMLSDAction action = new TMLSDAction( s + " = " + s1, instanceName );
		return action;
	}
}

/* Right-recursive grammar for parsing mathematical expressions in actions. No priority is given to operators */
String MAExpression():	//MA stands for Mathematical Action
{
	String s, s1;
}
{
	s = MATerm() s1 = MAExpressionPrime()	{ return s + s1; }
}

String MAExpressionPrime():
{
	String s, s1;
}
{
	<MATH_PLUS> s = MATerm() s1 = MAExpressionPrime()	{ return " + " + s + " " + s1; }
| <MATH_MINUS> s = MATerm() s1 = MAExpressionPrime() { return " - " + s + " " + s1; }
| <RIGHT_SLASH> s = MATerm() s1 = MAExpressionPrime() { return " / " + s + " " + s1; }
| <STAR_OP> s = MATerm() s1 = MAExpressionPrime() { return " * " + s + " " + s1; }
| {} { return ""; }
}

String MATerm():
{
	String s, s1;
}
{
	//MAFactor() MATermPrime()
	s = MAFactor() s1 = MATermPrime()	{ return s + s1; }
}

String MATermPrime():
{
	String s, s1;
}
{
	s = MAFactor() s1 = MATermPrime()	{ return s + s1; }
| {} { return ""; }
}

String MAFactor():
{
	String s;
	Token t;
}
{
	<LEFT_PARENTHESIS> s = MAExpression() <RIGHT_PARENTHESIS> { return "( " + s + " )"; }
	|
	s = ID() {return s; }
	|
	t = <INTEGER_LITERAL>	{ return t.image; }
}

/* Right-recursive grammar for parsing boolean expressions in actions. No priority is given to boolean operators */
String BAExpression():	//BA stands for Boolean Action
{
	String s, s1;
}
{
	s = BATerm() s1 = BAExpressionPrime()	{ return s + s1; }
}

String BAExpressionPrime():
{
	String s, s1;
}
{
	<LOGICALOR> s = BATerm() s1 = BAExpressionPrime()	{ return " || " + s + s1; }
| <LOGICALAND> s = BATerm() s1 = BAExpressionPrime()	{ return " && " + s + s1; }
| <EQUALITY> s = BATerm() s1 = BAExpressionPrime()	{ return " == " + s + s1; }
| {}	{ return ""; }
}

String BATerm():
{
	String s, s1;
}
{
	s = BAFactor() s1 = BATermPrime()	{ return s + s1; }
}

String BATermPrime():
{
	String s, s1;
}
{
	s = BAFactor() s1 = BATermPrime()	{ return s + s1; }
| {}	{ return ""; }
}

String BAFactor():
{
	String s;
	Token t;
}
{
	<LEFT_PARENTHESIS> s = BAExpression() <RIGHT_PARENTHESIS>	{ return "( " + s + " )"; }
	|
	s = ID()	{ return s; }
	|
	t = <FALSECONST>	{ return t.image; }
	|
	t = <TRUECONST> { return t.image; }
}

String ID():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ jjtThis.setName(t.image); return t.image; }
}

/*###################################################################################"*/

TMLCPActivityDiagram ActivityDiagram( TMLCP mainCP ):
{
	String name;
	TMLCPActivityDiagram ad = null;
	TMLCPElement elem = null;
	TMLCPElement prev = null;
}
{
	<ACTIVITY_DIAGRAM> name = ID()
	{ ad = new TMLCPActivityDiagram( name, null ); }
	
	"MAIN" "<>;"
	{
		TMLCPStart start = new TMLCPStart( "start", null );
		ad.addTMLCPElement(start);
		prev = start;
	}
	( elem = parseReferenceToDiagram( mainCP )
	{
		if( elem != null )	{
			prev.addNextElement( elem );
			ad.addElement( elem );
			prev = elem;
		}
	}
	<SEQUENCING_OP> )*
	
	ad = parseForkJoin( ad, mainCP ) "><"	"END" "END" ID()
	{
		prev.addNextElement( fork1 );	// prev references the last elem parsed above by parseReferenceToDiagram()
		fork1 = new TMLCPFork( "fork1" + counter, null );
		TMLCPStop stop = new TMLCPStop( "stop" + counter, null );
		//ad.addElement( fork1 );
		join1.addNextElement( stop );	// (last element returned from the last parsing).addNextElement( stop );
		ad.addElement( stop );
		TraceManager.addDev( "Printing the Activity Diagram:\n" + ad.toString() );
		return ad;
	}
}

TMLCPElement parseReferenceToDiagram( TMLCP mainCP ):
{
	String name;
	TMLCPElement elem;
	boolean isSD = false;
}
{
	name = ID()	//( ( name = ID() ) | "><" ) )*
	{ 
		for( TMLCPSequenceDiagram sd: mainCP.getCPSequenceDiagrams() )	{
			if( sd.getName().equals( name ) )	{
				isSD = true;
			}
		}
		if( isSD )	{
			elem = new TMLCPRefSD( name, null );
			return elem;
		}
		else	{
			elem = new TMLCPRefAD( name, null );
			//nexts.add( elem );
			return elem;
		}
	}
}

//Modify the data structure of the activity diagram as TMLCPElement is an abstract class, so it is not possible to instantiate an
//ArrayList<TMLCPElement> to be returned after parsing the fork-join
TMLCPActivityDiagram parseForkJoin( TMLCPActivityDiagram ad, TMLCP mainCP ):
{
	String name;
	TMLCPElement elem;
	TMLCPElement prev;
	boolean isSD = false;
	//TMLCPFork fork = new TMLCPFork( "fork" + counter , null );
	fork1 = new TMLCPFork( "fork1" + counter , null );
	join1 = new TMLCPJoin( "join1" + counter , null );
	counter++;
}
{
	"{" "{" elem = parseReferenceToDiagram( mainCP )
	{
		fork1.addNextElement( elem );	//the next element of Fork is only the first element of the sequence
		ad.addElement( elem );
		prev = elem;
	}
	// from now on is like parsing a normal sequence, in the sense that I ignore the fact of being inside a fork-join
	(
	<SEQUENCING_OP> elem = parseReferenceToDiagram( mainCP )
	{
		if( elem != null )	{
			prev.addNextElement( elem );
			ad.addElement( elem );
			prev = elem;
		}
	}
	)*
	"}"	// end of the first branch
	{ prev.addNextElement( join1 ); }
	( "*" "{" elem = parseReferenceToDiagram( mainCP )
	{
		fork1.addNextElement( elem );
		ad.addElement( elem );
		prev = elem;
	}
	"}"
	{ prev.addNextElement( join1 ); }
	)+	"};"
	{
		ad.addElement( fork1 );
		ad.addElement( join1 );
		return ad;
	}
}

/*void parseJunctionChoice():
{}
{
	ID()
}*/
