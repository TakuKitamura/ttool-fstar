/* Generated By:JavaCC: Do not edit this line. FstarTranspilerVisitor.java Version 4.1d1 */

package fstar.transpiler;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

// TODO: マイナス符号の対応を検討
// TODO: 整数以外の型への対応

public class FstarTranspilerVisitorImpl implements FstarTranspilerVisitor {

    public FstarTranspilerVisitorImpl() {

    }

    public FstarTranspilerVisitorImpl(MethodDeclaration methodDeclaration) {
        this.methodDeclaration = methodDeclaration;
    }

    // private Map<String, String> typeMap = new HashMap<String, String>() {
    // {
    // put("int32", "I32");
    // }
    // };

    private boolean haveMinusSign = false;

    // 関数宣言の読み取り結果
    private MethodDeclaration methodDeclaration = null;

    // 読み取ったリファインメントタイプの変数と値
    private Map<String, String> argMap = new HashMap<String, String>();

    public Object filterObjException(Object obj) throws Exception {
        if (obj instanceof Exception) {
            Exception e = (Exception) obj;
            throw e;
        }
        return obj;
    }

    private String generateFstarFormat(List<String> values, String op) throws Exception {

        // TODO: マイナス実装を考える

        System.out.println(values);
        System.out.println(op);

        Map<String, String> typeMap = new HashMap<String, String>() {
            {
                put("int32", "I32");
            }
        };

        Map<String, String> typeSuffixMap = new HashMap<String, String>() {
            {
                put("int32", "l");
            }
        };

        String x = values.get(0);

        String xType = null;

        String xVariableType = methodDeclaration.args.get(x);

        if (methodDeclaration.args.get(x) != null) { // variable
            xType = typeMap.get(xVariableType);
        } else if (x.equals("ret") == true) {
            xVariableType = methodDeclaration.returnType;
            xType = typeMap.get(methodDeclaration.returnType);
        } else { // value

        }

        String y = values.get(1);

        String yType = null;

        String yVariableType = methodDeclaration.args.get(y);

        if (methodDeclaration.args.get(y) != null) { // variable
            yType = typeMap.get(yVariableType);
        } else if (y.equals("ret") == true) {
            yVariableType = methodDeclaration.returnType;
            yType = typeMap.get(methodDeclaration.returnType);
        } else { // value

        }

        System.out.printf("xVariableType = %s, yVariableType = %s\n", xVariableType, yVariableType);
        if (xVariableType == null && yVariableType != null) {
            String suffix = typeSuffixMap.get(yVariableType);
            x += suffix;
        } else if (xVariableType != null && yVariableType == null) {
            String suffix = typeSuffixMap.get(xVariableType);
            y += suffix;
        }

        System.out.printf("%s, %s\n", x, y);

        if (xType == null && yType == null && x.equals("ret") == false && y.equals("ret") == false) {
            throw new Exception("find no need formula");
        }

        String type = null;

        if (xType != null) {
            System.out.printf("xType: %s\n", xVariableType);
            type = xType;
        } else {
            System.out.printf("yType: %s\n", yVariableType);
            type = yType;
        }

        Map<String, String> opeMap = new HashMap<String, String>() {
            {
                put("==", "eq");
                put("!=", "neq"); // fstar don't have neq ope
                put("<", "lt");
                put("<=", "lte");
                put(">", "gt");
                put(">=", "gte");
            }
        };

        String fstarOpName = opeMap.get(op); // I32
        String fstarOp = String.format("%s.%s", type, fstarOpName); // gt

        String ret = String.format("(%s %s %s)", fstarOp, x, y);
        if (op.equals("neq")) {
            String[] sepalate_op = op.split(" ", 2);
            String not = sepalate_op[0]; // not
            op = sepalate_op[1]; // I32
            ret = String.format("(%s (%s %s %s))", not, fstarOp, x, y);
        }

        return ret;
    }

    @Override
    public Object visit(SimpleNode node, Object data) {
        System.out.println(node);
        return null;
    }

    @Override
    public Object visit(ASTConditionRoot node, Object data) {
        System.out.println(node);

        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTExpr node, Object data) {
        System.out.println(node);
        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTConditionalOrExpression node, Object data) {
        System.out.println(node);

        try {
            String ret = "(";

            int leafNum = node.jjtGetNumChildren();

            if (leafNum == 1) {
                return filterObjException(node.jjtGetChild(0).jjtAccept(this, null)).toString();
            }

            for (int i = 0; i < leafNum; i++) {
                Node n = node.jjtGetChild(i);
                String leaf = filterObjException(n.jjtAccept(this, null)).toString();
                ret += leaf;
                if (i != leafNum - 1) {
                    ret += " || ";
                }
            }
            ret += ")";

            return ret;
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTConditionalAndExpression node, Object data) {
        System.out.println(node);
        try {

            String ret = "(";

            int leafNum = node.jjtGetNumChildren();

            if (leafNum == 1) {
                return filterObjException(node.jjtGetChild(0).jjtAccept(this, null)).toString();
            }

            for (int i = 0; i < leafNum; i++) {
                Node n = node.jjtGetChild(i);
                String leaf = filterObjException(n.jjtAccept(this, null)).toString();
                ret += leaf;
                if (i != leafNum - 1) {
                    ret += " && ";
                }
            }

            ret += ")";

            return ret;
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTEqualityExpression node, Object data) {
        System.out.println(node);
        try {

            int leafNum = node.jjtGetNumChildren();

            if (leafNum == 1) {
                return filterObjException(node.jjtGetChild(0).jjtAccept(this, null)).toString();
            }

            String op = (String) node.jjtGetValue();

            List<String> leafs = new ArrayList<>();
            for (int i = 0; i < leafNum; i++) {
                Node n = node.jjtGetChild(i);
                String leaf = filterObjException(n.jjtAccept(this, null)).toString();
                leafs.add(leaf);
            }

            String ret = generateFstarFormat(leafs, op);

            return ret;
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTRelationalExpression node, Object data) {
        System.out.println(node);

        try {
            int leafNum = node.jjtGetNumChildren();

            if (leafNum == 1) {
                return filterObjException(node.jjtGetChild(0).jjtAccept(this, null)).toString();
            }

            String op = (String) node.jjtGetValue();

            List<String> leafs = new ArrayList<>();
            for (int i = 0; i < leafNum; i++) {
                Node n = node.jjtGetChild(i);
                String leaf = filterObjException(n.jjtAccept(this, null)).toString();
                leafs.add(leaf);
            }

            String ret = generateFstarFormat(leafs, op);

            return ret;
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTAdditiveExpression node, Object data) {
        System.out.println(node);
        try {
            if (node.jjtGetValue() != null && node.jjtGetValue().toString().equals("-")) {
                this.haveMinusSign = true;
            }
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTPrimaryPrefix node, Object data) {
        System.out.println(node);
        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTLiteral node, Object data) {
        System.out.println(node);
        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTName node, Object data) {
        System.out.println(node);
        try {

            String argName = (String) node.jjtGetValue();

            if (methodDeclaration.args.get(argName) == null && argName.equals(argName) == false) {
                throw new Exception("find unkown variable");
            }

            return argName;
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTInteger node, Object data) {
        System.out.println(node);
        try {

            String ret = (String) node.jjtGetValue();

            if (this.haveMinusSign) {
                ret = "-" + ret;
                this.haveMinusSign = false;
            }

            return ret;
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTFloating node, Object data) {
        System.out.println(node);
        try {

            String ret = (String) node.jjtGetValue();

            if (this.haveMinusSign) {
                ret = "-" + ret;
                this.haveMinusSign = false;
            }

            return ret;
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTCharacter node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTString node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTBooleanLiteral node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTNullLiteral node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }

    // Method

    @Override
    public Object visit(ASTMethodDeclarationRoot node, Object data) {
        System.out.println(node);
        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        System.out.println(node);

        try {
            Node resultTypeNode = (Node) node.jjtGetChild(0);
            while (true) {
                if (resultTypeNode.jjtGetNumChildren() == 0) {
                    methodDeclaration.returnType = (String) filterObjException(resultTypeNode.jjtAccept(this, null));
                    break;
                }
                resultTypeNode = resultTypeNode.jjtGetChild(0);
            }

            return filterObjException(node.jjtGetChild(1).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTResultType node, Object data) {
        System.out.println(node);
        try {
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTMethodDeclarator node, Object data) {
        System.out.println(node);

        try {
            String functionName = (String) node.jjtGetValue();
            methodDeclaration.funcName = functionName;
            return filterObjException(node.jjtGetChild(0).jjtAccept(this, null));
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTFormalParameters node, Object data) {
        System.out.println(node);

        try {
            methodDeclaration.args = new HashMap<String, String>();

            for (int i = 0; i < node.jjtGetNumChildren(); i++) {
                Node formalParameters = (Node) node.jjtGetChild(i);
                Node formalParameter = (Node) formalParameters.jjtGetChild(0);
                Node variableDeclaratorId = (Node) formalParameters.jjtGetChild(1);

                String argType = "";
                String argName = "";
                while (true) {
                    if (formalParameter.jjtGetNumChildren() == 0) {
                        argType = (String) filterObjException(formalParameter.jjtAccept(this, null));
                        break;
                    }

                    formalParameter = formalParameter.jjtGetChild(0);

                }

                argName += (String) filterObjException(variableDeclaratorId.jjtAccept(this, null));
                if (variableDeclaratorId.jjtGetNumChildren() == 1) {
                    argName += "[]";
                }

                methodDeclaration.args.put(argName, argType);
            }

            return null;
        } catch (Exception e) {
            return e;
        }

    }

    @Override
    public Object visit(ASTFormalParameter node, Object data) {
        System.out.println(node);
        return null;
    }

    public Object visit(ASTVoidType node, Object data) {
        System.out.println(node);

        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }

    }

    public Object visit(ASTType node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetChild(0).jjtAccept(this, null);
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTArrayBrackets node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTVariableDeclaratorId node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTPrimitiveType node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }

    @Override
    public Object visit(ASTPrimitiveBlacketType node, Object data) {
        System.out.println(node);
        try {
            return node.jjtGetValue();
        } catch (Exception e) {
            return e;
        }
    }
}
