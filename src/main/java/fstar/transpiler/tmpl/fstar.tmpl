module @module_name@

open LowStar.BufferOps
open FStar.HyperStack.ST
open LowStar.Printf
open C.String

module I8 = FStar.Int8
module I16 = FStar.Int16
module I32 = FStar.Int32
module I64 = FStar.Int64

module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64

module B = LowStar.Buffer

noeq type struct_error = {
  code: I32.t;
  message: C.String.t;
}

let none_error: struct_error = 
{
    code = 0l;
    message = !$"";
}

let ng_error: struct_error = 
{
    code = 1l;
    message = !$"input is invalid range value";
}

noeq type @struct_ret_name@ = {
    value: @ret_value_type@;
    error: struct_error;
}

let ng_ret: @struct_ret_name@ = {
    value = @ng_init_ret_value@;
    error = ng_error;
}

val @func_name@_body:
  @fstar_func_args@
Stack (ret: @struct_ret_name@) (requires fun h0 -> 
    @require_logic_constraint@
  )
  (ensures fun h0 ret h1 -> 
    @ensure_logic_constraint@
  )
let @func_name@_body @args@ =
  {
      value = @ok_init_ret_value@;
      error = none_error;
  }

val @func_name@: 
  @fstar_func_args@
  Stack (ret: @struct_ret_name@) (requires fun h0 -> 
    @require_logic_constraint@
  )
  (ensures fun h0 ret h1 -> 
    @ensure_logic_constraint@
  )
let @func_name@ @args@ = 
  if (@require@) then
    @func_name@_body @args@
  else
    ng_ret