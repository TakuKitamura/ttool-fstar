/*** File generated by GenISSLib version 2.0: DO NOT MODIFY ***/
#ifndef __cpu_st231_isa_st231_HH__
#define __cpu_st231_isa_st231_HH__
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
namespace st231 { 
using namespace std;
typedef uint32_t CodeType;

class Operation;
const unsigned int NUM_OPERATIONS_PER_PAGE = 4096;
class DecodeMapPage
{
public:
	DecodeMapPage(uint32_t key);
	~DecodeMapPage();
	uint32_t key;
	DecodeMapPage *next;
	Operation *operation[NUM_OPERATIONS_PER_PAGE];
};

class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType opcode, CodeType opcode_mask, Operation *(*decode)(CodeType, uint32_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType code, uint32_t addr);
};
const unsigned int NUM_DECODE_HASH_TABLE_ENTRIES = 4096;
class Decoder
{
public:
	Decoder();
	virtual ~Decoder();

	Operation*NCDecode(uint32_t addr);
	Operation *NCDecode(uint32_t addr, CodeType code);
	Operation *Decode(uint32_t addr);
	Operation *Decode(uint32_t addr, CodeType insn);
	virtual void Fetch(void *, uint32_t, uint32_t) = 0;
	void InvalidateDecodingCacheEntry(uint32_t addr);
	void InvalidateDecodingCache();

	void SetLittleEndian();
	void SetBigEndian();
private:
	bool little_endian;
	vector<DecodeTableEntry > decode_table;
	DecodeMapPage *mru_page;
	DecodeMapPage *decode_hash_table[NUM_DECODE_HASH_TABLE_ENTRIES];
	DecodeMapPage *FindPage(uint32_t page_key)
#if defined(__GNUC__) && (__GNUC__ >= 3)
	__attribute__((always_inline))
#endif
	;
};

} 

#line 48 "isa/st231.isa"

#include "cpu.hh"
#define DEBUG 1

#line 71 "cpu/st231_isa.hh"

#line 1 "sim_dependencies.isa"

#include <stdarg.h>

  typedef enum operand_type_t { GPR_T, GPB_T } operand_type_t;
  typedef enum operand_direction_t { INPUT_T, OUTPUT_T } operand_direction_t;

  typedef struct operand_t
  {
    operand_type_t type;
    operand_direction_t dir;
    int value;
    struct operand_t *next;
  } operand_t;

#define ST231_INPUT(_type, _value) \
{\
	operands[noperands].type = _type;\
	operands[noperands].dir = INPUT_T;\
	operands[noperands++].value = _value;\
}

#define ST231_OUTPUT(_type, _value) \
{\
	operands[noperands].type = _type;\
	operands[noperands].dir = OUTPUT_T;\
	operands[noperands++].value = _value;\
}

#define SBITSET {}

// ??? used for what???
#define LOCAL_DEBUG \
{\
  for(int _i=0; _i<64; _i++)\
  {\
    ST231_INPUT(GPR_T,_i)\
    ST231_OUTPUT(GPR_T,_i)\
  }\
  return;\
}

  typedef operand_t operands_t[64];


#line 118 "cpu/st231_isa.hh"

#line 1 "sim_latencies.isa"


typedef unsigned int latencies_t[8];
#define LAT(lat) (latencies[nstages++] = (lat), latency += (lat))


#line 127 "cpu/st231_isa.hh"

#line 1 "sim_functions.isa"

typedef uint32_t function_t;

#define FnInvalid              0x00000000
#define FnNop                  0x00000001
#define FnIntBasic             0x00000002
#define FnIntExtended          0x00000004

#define FnBranch               0x10000000
#define FnConditionalBranch    0x10000001
#define FnBranchLinkReg        0x10000002
#define FnCondRegister         0x10000004
#define FnBranchLink           0x10000008

#define FnSysCall              0x20000000
#define FnSysRegister          0x20000001
#define FnMac                  0x20000002

#define FnLoad                 0x40000000
#define FnLoadByte             0x40000001
#define FnStore                0x40000002
#define FnStoreByte            0x40000004


#line 154 "cpu/st231_isa.hh"
#ifndef ROTL
#define ROTL(v, n) (((v) << (n)) | (((v) >> ((sizeof(v) * 8) - (n))) & ((1 << (n)) - 1)))
#endif
#ifndef ROTR
#define ROTR(v, n) (((v) >> (n)) | (((v) & ((1 << (n)) - 1)) << ((sizeof(v) * 8) - (n))))
#endif
#ifndef SEXT
#define SEXT(m, n, v) (((int##m##_t) (v) << (n)) >> (n))
#endif
namespace st231 { 
class Operation
{
public:
	Operation(CodeType code, uint32_t addr, const char *name);
	virtual ~Operation();
	inline uint32_t GetAddr() { return addr; }
	inline uint32_t GetEncoding() { return encoding; }
	inline const char *GetName() { return name; }

#line 46 "sim_dependencies.isa"
	int noperands;
#line 176 "cpu/st231_isa.hh"

#line 47 "sim_dependencies.isa"
	operands_t operands;
#line 180 "cpu/st231_isa.hh"

#line 8 "sim_latencies.isa"
	unsigned int latency;
#line 184 "cpu/st231_isa.hh"

#line 9 "sim_latencies.isa"
	int nstages;
#line 188 "cpu/st231_isa.hh"

#line 10 "sim_latencies.isa"
	latencies_t latencies;
#line 192 "cpu/st231_isa.hh"

#line 27 "sim_functions.isa"
	function_t function;
#line 196 "cpu/st231_isa.hh"
	virtual 
#line 52 "sim_loadstore.isa"
	uint32_t
#line 200 "cpu/st231_isa.hh"
	loadstore_effective_address(
#line 52 "sim_loadstore.isa"
	CPU *
#line 204 "cpu/st231_isa.hh"

#line 52 "sim_loadstore.isa"
	cpu
#line 208 "cpu/st231_isa.hh"
	);
	virtual 
#line 23 "sim_loadstore.isa"
	int
#line 213 "cpu/st231_isa.hh"
	memory_access_size(
#line 23 "sim_loadstore.isa"
	CPU *
#line 217 "cpu/st231_isa.hh"

#line 23 "sim_loadstore.isa"
	cpu
#line 221 "cpu/st231_isa.hh"
	);
	virtual 
#line 4 "sim_loadstore.isa"
	int
#line 226 "cpu/st231_isa.hh"
	loadstore_target_register(
#line 4 "sim_loadstore.isa"
	CPU *
#line 230 "cpu/st231_isa.hh"

#line 4 "sim_loadstore.isa"
	cpu
#line 234 "cpu/st231_isa.hh"
	);
	virtual void	initialize_function(	);
	virtual void	initialize_latencies(	);
	virtual void	initialize_operands(	);
	virtual 
#line 58 "isa/st231.isa"
	void
#line 242 "cpu/st231_isa.hh"
	disasm(
#line 58 "isa/st231.isa"
	CPU *
#line 246 "cpu/st231_isa.hh"

#line 58 "isa/st231.isa"
	cpu
#line 250 "cpu/st231_isa.hh"
,

#line 58 "isa/st231.isa"
	ostream&
#line 255 "cpu/st231_isa.hh"

#line 58 "isa/st231.isa"
	os
#line 259 "cpu/st231_isa.hh"
	);
	virtual 
#line 53 "isa/st231.isa"
	void
#line 264 "cpu/st231_isa.hh"
	execute(
#line 53 "isa/st231.isa"
	CPU *
#line 268 "cpu/st231_isa.hh"

#line 53 "isa/st231.isa"
	cpu
#line 272 "cpu/st231_isa.hh"
	);
private:
	CodeType encoding;
	uint32_t addr;
	const char *name;
};

} 
#endif
